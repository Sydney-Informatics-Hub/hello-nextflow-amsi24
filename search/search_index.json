{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hello Nextflow!","text":"<p>This workshop will put you on the path to writing your own reproducible and scalable scientific workflows using Nextflow. You will learn how to use core Nextflow components to build, run and troubleshoot a simple multi-step workflow.  </p>"},{"location":"#trainers","title":"Trainers","text":"<ul> <li>Fred Jaya, Sydney Informatics Hub, University of Sydney</li> <li>Ziad Al Bkhetan, Australian BioCommons</li> <li>Georgie Samaha, Sydney Informatics Hub, University of Sydney</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>This is an intermediate workshop for people developing reproducuble bioinformatics workflows.</p> <ul> <li>Command line and linux skills are essential. The workshop will be conducted in a Unix environment.  </li> <li>(Strongly recommended) Experience developing reproducible workflows (e.g., bash, CWL, WDL, or Snakemake).  </li> </ul>"},{"location":"#set-up-requirements","title":"Set up requirements","text":"<p>Please complete the Setup instruction before the workshop. If you have any trouble, please get in contact with us ASAP via Slack.</p>"},{"location":"#code-of-conduct","title":"Code of Conduct","text":"<p>In order to foster a positive and professional learning environment we encourage the following kinds of behaviours at all our events and on our platforms:</p> <ul> <li>Use welcoming and inclusive language</li> <li>Be respectful of different viewpoints and experiences</li> <li>Gracefully accept constructive criticism</li> <li>Focus on what is best for the community</li> <li>Show courtesy and respect towards other community members</li> <li>Our full code of conduct, with incident reporting guidelines, is available here.</li> </ul>"},{"location":"#workshop-schedule","title":"Workshop schedule","text":"Time (AEDT) Activity 13:00 Welcome and set up 13:20 Introduction to Nextflow 13:30 Bioinformatics demo 13:40 Workshop sections 1-2 14:30 BREAK 15:00 Workshop sections 3-4 15:50 Where to next? 16:00 Workshop end"},{"location":"#credits-and-acknowledgements","title":"Credits and acknowledgements","text":"<p>This workshop event and accompanying materials were developed by the Sydney Informatics Hub, University of Sydney in partnership with Seqera. The workshop was enabled through the Australian BioCommons - BioCLI Platforms Project (NCRIS via Bioplatforms Australia). </p> <p></p>"},{"location":"resources/","title":"Supporting materials","text":""},{"location":"resources/#recommended-resources","title":"Recommended resources","text":"<p>Here are some useful resources we recommend to help you get started with running nf-core pipelines and developing Nextflow pipelines:</p>"},{"location":"resources/#developed-by-us","title":"Developed by us","text":"<ul> <li>SIH Nextflow template</li> <li>SIH Nextflow template guide</li> <li>SIH Customising nf-core workshop</li> <li>Australian BioCommons Seqera Platform Service</li> <li>NCI Gadi nf-core instutitonal config</li> <li>Pawsey Setonix nf-core instutitional config</li> </ul>"},{"location":"resources/#developed-by-others","title":"Developed by others","text":"<ul> <li>Nextflow training</li> <li>Nextflow patterns</li> <li>Nextflow blog</li> <li>Nextflow coding best practice recommendations</li> <li>Seqera community forums</li> </ul>"},{"location":"resources/#nextflow-tips-and-tricks","title":"Nextflow tips and tricks","text":"<p>Nextflow has some useful features for executing pipelines and querying metadata and history. Here are some resources to help you get started.</p>"},{"location":"resources/#query-specific-pipeline-executions","title":"Query specific pipeline executions","text":"<p>The Nextflow log command is useful for querying execution metadata and history. You can filter your queries and output specific fields in the printed log. </p> <pre><code>nextflow log &lt;run_name&gt; -help\n</code></pre>"},{"location":"resources/#execute-nextflow-in-the-background","title":"Execute Nextflow in the background","text":"<p>The <code>-bg</code> options allows you to run your pipeline in the background and continue using your terminal. It is similar to <code>nohup</code>. You can redirect all standard output to a log file. </p> <pre><code>nextflow run &lt;workflow_repo/main.nf&gt; -bg &gt; workshop_tip.log\n</code></pre>"},{"location":"resources/#capture-a-nextflow-pipelines-configuration","title":"Capture a Nextflow pipeline's configuration","text":"<p>The Nextflow config command prints the resolved pipeline configuration. It is especially useful for printing all resolved parameters and profiles Nextflow will use to run a pipeline. </p> <pre><code>nextflow config &lt;workflow_repo&gt; -help\n</code></pre>"},{"location":"resources/#clean-nextflow-cache-and-work-directories","title":"Clean Nextflow cache and work directories","text":"<p>The Nextflow clean command will remove files from previous executions stored in the <code>.nextflow</code> cache and <code>work</code> directories. The <code>-dry-run</code> option allows you to preview which files will be deleted. </p> <pre><code>nextflow clean &lt;workflow_repo&gt; -help\n</code></pre>"},{"location":"resources/#change-default-nextflow-cache-strategy","title":"Change default Nextflow cache strategy","text":"<p>Workflow execution is sometimes not resumed as expected. The default behaviour of Nextflow cache keys is to index the input files meta-data information. Reducing the cache stringency to <code>lenient</code> means the files cache keys are based only on filesize and path, and can help to avoid unexpectedly re-running certain processes when <code>-resume</code> is in use. </p> <p>To apply lenient cache strategy to all of your runs, you could add to a custom configuration file:</p> <pre><code>process {\n    cache = 'lenient'\n}\n</code></pre> <p>You can specify different cache stategies for different processes by using <code>withName</code> or <code>withLabel</code>. You can specify a particular cache strategy be applied to certain <code>profiles</code> within your institutional config, or to apply to all profiles described within that config by placing the above <code>process</code> code block outside the <code>profiles</code> scope.    </p>"},{"location":"resources/#access-private-github-repositories","title":"Access private GitHub repositories","text":"<p>To interact with private repositories on GitHub, you can provide Nextflow with access to GitHub by specifying your GitHub user name and a Personal Access Token in the <code>scm</code> configuration file inside your specified <code>.nextflow/</code> directory:</p> <pre><code>providers {\n\n  github {\n    user = 'georgiesamaha'\n    password = 'my-personal-access-token'\n  }\n\n}\n</code></pre>"},{"location":"setup/","title":"Setting up your computer","text":"<p>In this workshop, we will be using Virtual Machines (VM) on the ARDC Nectar Research Cloud.</p> <p>The requirements for this workshop are a personal computer with:</p> <ul> <li>Visual Studio Code (VSCode)</li> <li>A web browser</li> </ul> <p>Below, you will find instructions on how to set up VSCode and connect toyour VM. Each participant will be provided with their instances IP address prior to the workshop. Before the workshop, you must have the following:</p> <ol> <li>VSCode installed.</li> <li>The necessary VSCode extensions installed.</li> <li>Be able to connect to your VM.  </li> </ol> <p>Info</p> <p>If you require assistance with the setup, please message the Slack channel!</p>"},{"location":"setup/#installing-visual-studio-code","title":"Installing Visual Studio Code","text":"<p>Visual Studio Code (VSCode) is a versatile code editor that we will use for the workshop. We will use VSCode to connect to the VM, navigate the directories, edit, view and download files. </p> <ol> <li>Download VSCode by following the  installation instructions for your local Operating System.  </li> <li>Open VSCode to confirm it was installed correctly.  </li> </ol> <p></p>"},{"location":"setup/#installing-the-vscode-extensions","title":"Installing the VSCode extensions","text":"<p>Specific VSCode extensions are required to connect to the VM and make working with Nextflow files easier (i.e. syntax highlighting).  </p> <ol> <li>In the VSCode sidebar on the left, click on the extensions button (four blocks).</li> <li>In the Extensions Marketplace search bar, search for <code>remote ssh</code>. Select \"Remote - SSH\".</li> </ol> <p> 3. Click on the blue <code>Install</code> button.</p> <p> 4. Search for <code>nextflow</code> and install the \"Nextflow\" extension.  </p> <p> 5. Close the Extensions tab and sidebar</p>"},{"location":"setup/#setting-up-your-remote-ssh-config","title":"Setting up your remote SSH config","text":"<ol> <li>In VSCode, press <code>Ctrl+Shift+P</code> (<code>Command+Shift+P</code> on mac) to open the Command Palette.  </li> </ol> <p> 2. Type <code>remote ssh</code> and select <code>Remote-SSH: Add New SSH Host...</code>. This may appear in a different position in the list.</p> <p> 3. Enter the SSH connection string with the IP address that was provided to you. The connection string should look like <code>ssh user1@XXX.XXX.XX.XX</code>. Ensure that you replace the \"XXX...\" with your allocated IP address. Press <code>Enter</code>.</p> <p> 4. You will be prompted to <code>Select SSH configuration file to update</code>. Select your <code>.ssh/config</code> file. </p> <p> 5. You should receive a pop-up informing that a host as been added!</p>"},{"location":"setup/#connecting-to-the-vm","title":"Connecting to the VM","text":"<p>Ensure you have configured your SSH details.  </p> <ol> <li> <p>In VSCode, press <code>Ctrl+Shift+P</code> (<code>Command+Shift+P</code> on mac) to open the Command Palette.  </p> </li> <li> <p>Type <code>remote ssh</code> and select <code>Remote-SSH: Connect to Host...</code>. This may appear in a different position in the list.</p> </li> </ol> <p> 3. Select the IP address that you have configured. If you are prompted for a platform, select \"Linux\". 4. A new VSCode window will open and prompt you for your password. Input your allocated password and hit 'Enter'. </p> <p> 5. In the pop-up, Select \"Yes, I trust the authors\" 6. Once the blue square in the bottom-left of the VSCode window shows  <code>SSH: XXX.XXX.XX.XX</code> - you have successfully connected to your instance!  </p> <p> </p>"},{"location":"setup/#configuring-vscode-for-the-workshop","title":"Configuring VSCode for the workshop","text":"<ol> <li>Select the File Explorer on the left sidebar (icon with two pages) or press  <code>Ctrl+Shift+E</code> (Mac: <code>Cmd+Shift+E</code>).  </li> </ol> <p> 2. Select <code>Open Folder</code></p> <p> 3. The correct file path should be input by default (<code>/home/userX/</code>). Press 'OK'. 4. The home directory will appear in the left side bar.  </p> <p> 6. In the Explorer sidebar, select <code>.main.nf</code>. This file will open in a tab. You may need to re-enter you password again.  7. Check that syntax highlighting (different parts of the Nextflow code are  coloured) is enabled as shown. This is to confirm the VSCode Nextflow extension is working correctly.  </p> <p> </p> <p>Warning</p> <p>The <code>.main.nf</code> file is for testing purposes only. We will not touch this file in the workshop.</p> <p>8. Toggle the terminal in VSCode by pressing `Ctrl+j` (`Cmd+j` on mac).</p> <p> </p> <p>Success</p> <p>You have now configured VSCode for the workshop! </p>"},{"location":"content/00_intro/","title":"Welcome","text":"<p>In this workshop, you will create a toy multi-step Nextflow workflow.</p> <p>We will start by familiarizing ourselves with some common bash commands. Next, we will turn these commands into a small single-step Nextflow pipeline that will print a greeting to our terminal. In a series of exercises, we will then iterate on this pipeline to make it more flexible using variable outputs, inputs, and parameters.</p> <p>As a bonus, we will add a second step to the pipeline to dynamically turn our greeting into uppercase letters and name pipeline outputs.</p>"},{"location":"content/00_intro/#moving-into-your-work-directory","title":"Moving into your work directory","text":"<p>It is good practice to organize projects into their own folders to make it easier to track and replicate experiments over time.</p> <p>For this workshop, all work will be conducted in the <code>~/part1/</code> folder.</p> <p>Exercise</p> <p>In the VSCode terminal, move into the directory for all Part 1 activities:</p> <pre><code>cd ~/part1\n</code></pre>"},{"location":"content/01_hellonextflow/","title":"Why Nextflow?","text":"<p>Learning objectives</p> <ol> <li>Describe the benefits of using Nextflow to write complex pipelines</li> <li>List community resources you can access to get help developing your pipelines</li> </ol> <p>Nextflow is a workflow orchestration engine and domain-specific language (DSL) that makes it easy to write data-intensive computational workflows.</p> <p>It is designed around the idea that the Linux platform is the lingua franca of data science. Linux provides many simple but powerful command-line and scripting tools that, when chained together, facilitate complex data manipulations.</p> <p>Nextflow extends this approach, adding the ability to define complex program interactions and a high-level parallel computational environment based on the dataflow programming model.</p>"},{"location":"content/01_hellonextflow/#core-features","title":"Core features","text":"<p>Nextflow\u2019s core features are:</p> <ul> <li>Workflow portability and reproducibility</li> <li>Scalability of parallelization and deployment</li> <li>Integration of existing tools, systems, and industry standards</li> </ul>"},{"location":"content/01_hellonextflow/#processes-tasks-and-channels","title":"Processes, tasks, and channels","text":"<p>A Nextflow workflow is made by joining together processes. Each process can be written in any scripting language that can be executed by the Linux platform Processes can be written in any language that can be executed from the command line, such as Bash, Python, or R.</p> <p>Processes in are executed independently (i.e., they do not share a common writable state) as tasks and can run in parallel, allowing for efficient utilization of computing resources. Nextflow automatically manages the data dependencies between processes, ensuring that each process is executed only when its input data is available and all of its dependencies have been satisfied.</p> <p>The only way they can communicate is via asynchronous first-in, first-out (FIFO) queues, called channels. Simply, every input and output of a process is represented as a channel. The interaction between these processes, and ultimately the workflow execution flow itself, is implicitly defined by these input and output declarations.</p> <p></p>"},{"location":"content/01_hellonextflow/#execution-abstraction","title":"Execution abstraction","text":"<p>While a process defines what command or script is executed, the executor determines how and where the script is executed.</p> <p>Nextflow provides an abstraction between the workflow\u2019s functional logic and the underlying execution system. This abstraction allows users to define a workflow once and execute it on different computing platforms without having to modify the workflow definition. Nextflow provides a variety of built-in execution options, such as local execution, HPC cluster execution, and cloud-based execution, and allows users to easily switch between these options using command-line arguments.</p> <p></p>"},{"location":"content/01_hellonextflow/#more-information","title":"More information","text":"<p>This workshop focuses on basic skills for developers.</p> <p>Follow these links to find out more about Nextflow:</p> <ul> <li>Nextflow docs</li> <li>nf-core</li> <li>Nextflow training</li> <li>Reproducible workflows with nf-core</li> <li>Seqera community</li> </ul> <p>Summary</p> <p>In this step you have learned:</p> <ol> <li>How to describe different parts of a Nextflow pipeline</li> <li>How to find more information</li> </ol>"},{"location":"content/02_helloworld/","title":"Hello World!","text":"<p>Learning objectives</p> <ol> <li>Utilize simple bash commands to manipulate strings</li> </ol> <p>A Hello, World! is a minimalist example that is meant to demonstrate the basic syntax and structure of a programming language or software framework. The example typically consists of printing the phrase 'Hello World!' to the output, such as the console or terminal, or writing it to a file.</p> <p>Let's demonstrate this with simple commands that you can run directly in the terminal.</p>"},{"location":"content/02_helloworld/#print-a-string","title":"Print a string","text":"<p>The <code>echo</code> command in Linux is a built-in command that allows users to display lines of text or strings that are passed as arguments. It is commonly used in shell scripts and batch files to output status text to the screen or a file.</p> <p>The most straightforward usage of the <code>echo</code> command is to display a text or string on the terminal. To do this, you simply provide the desired text or string as an argument to the <code>echo</code> command:</p> <pre><code>echo &lt;string&gt;\n</code></pre> <p>Exercise</p> <p>Use the <code>echo</code> command to print the string <code>'Hello World!'</code> to the terminal.</p> Solution <pre><code>echo 'Hello World!'\n</code></pre>"},{"location":"content/02_helloworld/#redirect-outputs","title":"Redirect outputs","text":"<p>The output of the <code>echo</code> can be redirected to a file instead of displaying it on the terminal. You can achieve this by using the <code>&gt;</code> operator for output redirection. For example:</p> <pre><code>echo 'Welcome!' &gt; output.txt\n</code></pre> <p>This will write the output of the echo command to the file name <code>output.txt</code>.</p> <p>Exercise</p> <p>Use the <code>&gt;</code> operator to redirect the output of echo to a file named <code>output.txt</code>.</p> Solution <pre><code>echo 'Hello World!' &gt; output.txt\n</code></pre>"},{"location":"content/02_helloworld/#list-files","title":"List files","text":"<p>The Linux shell command <code>ls</code> lists directory contents of files and directories. It provides valuable information about files, directories, and their attributes.</p> <p><code>ls</code> will display the contents of the current directory:</p> <pre><code>ls\n</code></pre> <p>Exercise</p> <p>List the files in the working directory to verify <code>output.txt</code> was created.</p> Solution <pre><code>ls\n</code></pre> <p>A file named <code>output.txt</code> should now be listed in your current directory.</p>"},{"location":"content/02_helloworld/#view-file-contents","title":"View file contents","text":"<p>The <code>cat</code> command in Linux is a versatile companion for various file-related operations, allowing users to view, concatenate, create, copy, merge, and manipulate file contents.</p> <p>The most basic use of <code>cat</code> is to display the contents of a file on the terminal. This can be achieved by simply providing the filename as an argument:</p> <pre><code>cat &lt;file name&gt;\n</code></pre> <p>Exercise</p> <p>Use the <code>cat</code> command to print the contents of <code>output.txt</code>.</p> Solution <pre><code>cat output.txt\n</code></pre> <p>You should see <code>Hello World!</code> printed to your terminal.</p> <p>Summary</p> <p>In this step you have learned:</p> <ol> <li>How to use the <code>echo</code> command to print a string to the terminal</li> <li>How to use the <code>&gt;</code> operator to redirect the output of <code>echo</code></li> <li>How to use the <code>ls</code> command to list the files in your working directory</li> <li>How to use the <code>cat</code> command to print the contents of files</li> </ol>"},{"location":"content/03_hellonf/","title":"Your first pipeline","text":"<p>Learning objectives</p> <ol> <li>Write your first  Nextflow pipeline</li> <li>Execute your first Nextflow pipeline and understand the outputs</li> </ol> <p>Workflow languages are better than Bash scripts because they handle errors and run tasks in parallel more easily, which is important for complex jobs. They also have clearer structure, making it easier to maintain and work on with others.</p> <p>Here, you're going learn more about the Nextflow language and take your first steps making a your first pipeline with Nextflow.</p>"},{"location":"content/03_hellonf/#hello-worldnf","title":"<code>hello-world.nf</code>","text":"<p>Nextflow pipelines need to be saved as <code>.nf</code> files.</p> <p>The process definition starts with the keyword <code>process</code>, followed by process name, and finally the process body delimited by curly braces. The process body must contain a <code>script</code> block which represents the command or, more generally, a script that is executed by it.</p> <p>A process may contain any of the following definition blocks: <code>directives</code>, <code>inputs</code>, <code>outputs</code>, <code>when</code> clauses, and of course, <code>script</code>.</p> <pre><code>process &lt; name &gt; {\n  [ directives ]\n\n  input:\n    &lt; process inputs &gt;\n\n  output:\n    &lt; process outputs &gt;\n\n  when:\n    &lt; condition &gt;\n\n  script:\n  \"\"\"\n  &lt;script to be executed&gt;\n  \"\"\"\n}\n</code></pre> <p>A workflow is a composition of processes and dataflow logic.</p> <p>The workflow definition starts with the keyword <code>workflow</code>, followed by an optional name, and finally the workflow body delimited by curly braces.</p> <p>Let's review the structure of <code>hello-world.nf</code>, a toy example you will be executing and developing:</p> hello-world.nf<pre><code>process SAYHELLO {\n    debug true\n\n    output:\n    stdout\n\n    script:\n    \"\"\"\n    echo 'Hello World!'\n    \"\"\"\n}\n\nworkflow {\n    SAYHELLO()\n}\n</code></pre> <p>The first piece of code (lines 1-11) describes a process called <code>SAYHELLO</code> with three definition blocks:</p> <ul> <li>debug: a directive that, when set to true, will print the output to the console</li> <li>output: directing outputs to be printed to <code>stdout</code> (standard output)</li> <li>script: the <code>echo 'Hello World!'</code> command</li> </ul> <p>The second block of code (13-15) lines describes the workflow itself, which consists of one call to the <code>SAYHELLO</code> process.</p> <p>Note</p> <p>Using <code>debug true</code> and <code>stdout</code> in combination will cause 'Hello World!' to be printed to the terminal.</p>"},{"location":"content/03_hellonf/#commenting-your-code","title":"Commenting your code","text":"<p>It is worthwhile to comment your code so we, and others, can easily understand what the code is doing (you will thank yourself later).</p> <p>In Nextflow, a single line comment can be added by prepending it with two forward slash (<code>//</code>):</p> <pre><code>// This is my comment\n</code></pre> <p>Similarly, multi-line comments can be added using the following format:</p> <pre><code>/*\n * Use echo to print 'Hello World!' to standard out\n */\n</code></pre> <p>As a developer you can to choose how and where to comment your code.</p> <p>Exercise</p> <p>Add a comment to the pipeline to describe what the process block is doing</p> Solution <p>The solution may look something like this:</p> hello-world.nf<pre><code>/*\n * Use echo to print 'Hello World!' to standard out\n */\nprocess SAYHELLO {\n&lt;truncated&gt;\n</code></pre> <p>Or this:</p> hello-world.nf<pre><code>// Use echo to print 'Hello World!' to standard out\nprocess SAYHELLO {\n&lt;truncated&gt;\n</code></pre> <p>As a developer, you get to choose!</p>"},{"location":"content/03_hellonf/#executing-hello-worldnf","title":"Executing <code>hello-world.nf</code>","text":"<p>The <code>nextflow run</code> command is used to execute Nextflow pipelines:</p> <pre><code>nextflow run &lt;pipeline.nf&gt;\n</code></pre> <p>When a pipeline is stored locally you need to supply the full path to the script. However, if the pipeline has been submitted to GitHub (and you have an internet connection) you can execute it without a local copy. For example, the hello repository hosted on the nextflow-io GitHub account can be executed using:</p> <pre><code>nextflow run nextflow-io/hello\n</code></pre> <p>Exercise</p> <p>Use the <code>nextflow run</code> command to execute <code>hello-world.nf</code></p> Solution <pre><code>nextflow run hello-world.nf\n</code></pre> <p>Yay! You have just run your first pipeline!</p> <p>Your console should look something like this:</p> <pre><code>N E X T F L O W  ~  version 23.10.1\nLaunching `hello-world.nf` [mighty_murdock] DSL2 - revision: 80e92a677c\nexecutor &gt;  local (1)\n[4e/6ba912] process &gt; SAYHELLO [100%] 1 of 1 \u2714\nHello World!\n</code></pre> <p>What does each line mean?</p> <ol> <li>The version of Nextflow that was executed</li> <li>The script and version names</li> <li>The executor used (in the above case: local)</li> <li>The first process is executed once, which means there is one task. The line starts with a unique hexadecimal value, and ends with the task completion information</li> <li>The result string from stdout is printed</li> </ol>"},{"location":"content/03_hellonf/#task-directories","title":"Task directories","text":"<p>When a Nextflow pipeline is executed, a <code>work</code> directory is created. Processes are executed in isolated task directories. Each task uses a unique directory based on its hash (e.g., <code>4e/6ba912</code>) within the work directory.</p> <p>When a task is created, Nextflow stages the task input files, script, and other helper files into the task directory. The task writes any output files to this directory during its execution, and Nextflow uses these output files for downstream tasks and/or publishing.</p> <p>These directories do not share a writable state, and any required files or information must be passed through channels (this will be important later).</p> <p>Note</p> <p>You can execute <code>tree work</code> to view the work directory structure.</p> <p>Warning</p> <p>The work directory might not have the same hash as the one shown above.</p> <p>A series of files log files and any outputs are created by each task in the work directory:</p> <ul> <li><code>.command.begin</code>: Metadata related to the beginning of the execution of the process task</li> <li><code>.command.err</code>: Error messages (stderr) emitted by the process task</li> <li><code>.command.log</code>: Complete log output emitted by the process task</li> <li><code>.command.out</code>: Regular output (<code>stdout</code>) by the process task</li> <li><code>.command.sh</code>: The command that was run by the process task call</li> <li><code>.exitcode</code>: The exit code resulting from the command</li> </ul> <p>These files are created by Nextflow to manage the execution of your pipeline. While these file are not required now, you may need to interrogate them to troubleshoot issues later.</p> <p>Exercise</p> <p>Browse the <code>work</code> directory and view the <code>.command.sh</code> file</p> Solution <p>Note: The hash may be different to the example shown below.</p> <pre><code>cat work/4e/6ba9138vhsbcbsc83bcka/.command.sh\n</code></pre> <p>Summary</p> <p>In this step you have learned:</p> <ol> <li>How to create a Nextflow pipeline</li> <li>How to interpret <code>hello-world.nf</code></li> <li>How to add comments to your pipelines</li> <li>How to <code>run</code> a Nextflow pipeline</li> <li>How to view log files create by Nextflow</li> </ol>"},{"location":"content/04_output/","title":"Outputs","text":"<p>Learning objectives</p> <ol> <li>Utlizie Nextflow process output blocks</li> <li>Publish results from your pipeline with directives</li> </ol> <p>Instead of printing 'Hello World!' to the standard output it can be saved to a file. In a \"real-world\" pipeline, this is like having a command that specifies an output file as part of its normal syntax.</p> <p>Here you're going to update the <code>script</code> and the <code>output</code> definition blocks to save the 'Hello World!' as an output.</p>"},{"location":"content/04_output/#redirecting-outputs","title":"Redirecting outputs","text":"<p>The script block will need to be updated to redirect the 'Hello World!' output to a file.</p> <p>The <code>&gt;</code> operator can be used for output redirection.</p> <p>Exercise</p> <p>Redirect 'Hello World!' to a file named 'output.txt' in the <code>script</code> block and add a comment to annotate your change.</p> Solution hello-world.nf<pre><code>// Use echo to print 'Hello World!' and redirect to output.txt\nprocess SAYHELLO {\n    debug true\n\n    output:\n    stdout\n\n    script:\n    \"\"\"\n    echo 'Hello World!' &gt; output.txt\n    \"\"\"\n}\n</code></pre>"},{"location":"content/04_output/#outputs-blocks","title":"Outputs blocks","text":"<p>Outputs in the output definition block typically require an output qualifier and a output name:</p> <pre><code>&lt;output qualifier&gt; &lt;output name&gt;\n</code></pre> <p>The output qualifier defines the type of data to be received. This information is used by Nextflow to apply the semantic rules associated with each qualifier, and handle it properly.</p> <p>Common output qualifiers include <code>val</code> and <code>path</code>:</p> <ul> <li><code>val</code>: Emit the variable with the specified name</li> <li>For example, <code>val 'Hello World!'</code></li> <li><code>path</code>: Emit a file produced by the process with the specified name</li> <li>For example, <code>path 'output.txt'</code></li> </ul> <p>See the Nextflow documentation for a full list of output qualifiers.</p> <p>Warning</p> <p>If you set the wrong qualifier the pipeline will likely throw errors.</p> <p>The output name is a name given to the output variable. If a specific file is being produced it can be named in single quotes:</p> hello-world.nf<pre><code>output:\npath 'output.txt'\n</code></pre> <p>The output name and the file generated by the script must match (or be picked up by a glob pattern).</p> <p>Exercise</p> <p>Add <code>path 'output.txt'</code> in the <code>SAYHELLO</code> output block.</p> Solution hello-world.nf<pre><code>// Use echo to print 'Hello World!' and redirect to output.txt\nprocess SAYHELLO {\n    debug true\n\n    output:\n    path 'output.txt'\n\n    script:\n    \"\"\"\n    echo 'Hello World!' &gt; output.txt\n    \"\"\"\n}\n</code></pre> <p>Warning</p> <p>This example is brittle because the output filename is hardcoded in two separate places (the <code>script</code> and the <code>output</code> definition blocks). If you change one but not the other, the script will break.</p>"},{"location":"content/04_output/#publishing-directory","title":"Publishing directory","text":"<p>Without a publishing strategy any files that are created by a process will only exist in the <code>work</code> directory.</p> <p>Realistically, you may want to capture a set of outputs and save them in a specific directory.</p> <p>The <code>publishDir</code> directive can be used to specify where and how output files should be saved. For example:</p> <pre><code>publishDir 'results'\n</code></pre> <p>By adding the above to a process, all output files would be saved in a new folder called <code>results</code> in the current working directory. The process directive is process specific.</p> <p>Exercise</p> <p>Replace <code>debug true</code> with <code>publishDir 'results'</code> in the <code>SAYHELLO</code> process block. Execute the pipeline again. View your new <code>results</code> folder in the working directory.</p> Solution hello-world.nf<pre><code>// Use echo to print 'Hello World!' and redirect to output.txt\nprocess SAYHELLO {\n    publishDir 'results'\n\n    output:\n    path 'output.txt'\n\n    script:\n    \"\"\"\n    echo 'Hello World!' &gt; output.txt\n    \"\"\"\n}\n</code></pre> <p>Summary</p> <p>In this step you have learned:</p> <ol> <li>How to redirect outputs</li> <li>How to use <code>output</code> block</li> <li>How to publish results</li> </ol>"},{"location":"content/05_inputs/","title":"Inputs","text":"<p>Learning objectives</p> <ol> <li>Describe Nextflow channel types</li> <li>Utlizie Nextflow process input blocks</li> </ol> <p>So far, you've been emitting a greeting ('Hello World!') that has been hardcoded into the script block. In a more realistic situation, you might want to pass a variable input to your script, much like you pass files to command line tools for analysis.</p> <p>Here you're going to to add some flexibility by introducing channels to your workflow and an input definition to your <code>SAYHELLO</code> process.</p>"},{"location":"content/05_inputs/#channels","title":"Channels","text":"<p>In Nextflow, processes primarily communicate through channels.</p> <p>Channels are created using channel factories.</p> <p>There are numerous types of channel factories which can be utilized for creating different channel types and data types.</p> <p>Importantly, there are two kinds of channels (queue channels and value channels) which behave differently.</p> <p>Queue channel</p> <ul> <li>A non-blocking unidirectional first-in first-out queue connecting a producer process (i.e. outputting a value) to a consumer process, or an operators.</li> <li>Can be consumed only once.</li> </ul> <p>Value channel</p> <ul> <li>Can be bound (i.e. assigned) with one and only one value.</li> <li>Can be consumed any number of times.</li> </ul> <p>You're going to start by creating a channel that will contain your greeting with the <code>Channel.of()</code> channel factory.</p> <p>Note</p> <p>You can build different kinds of channels depending on the shape of the input data.</p>"},{"location":"content/05_inputs/#channelof","title":"Channel.of()","text":"<p>The <code>Channel.of</code> method allows us to create a channel that emits the arguments provided to it. For example:</p> <pre><code>ch_greeting = channel.of('Hello World!')\n</code></pre> <p>Would create a channel (named <code>ch_greeting</code>) that contains the string 'Hello World!'</p> <p>Channels need to be created within the <code>workflow</code> definition.</p> <p>Exercise</p> <p>Create a channel named <code>greeting_ch</code> with the 'Hello World!' greeting.</p> Solution hello-world.nf<pre><code>workflow {\n\n    // Create a channel for inputs\n    greeting_ch = Channel.of('Hello world!')\n\n    // Emit a greeting\n    SAYHELLO()\n}\n</code></pre>"},{"location":"content/05_inputs/#input-definition-blocks","title":"Input definition blocks","text":"<p>Before <code>greeting_ch</code> can be passed to the <code>SAYHELLO</code> process as an input, you must first add an input block in the process definition.</p> <p>The inputs in the input block, much like the output block, must have a qualifier and a name:</p> <pre><code>&lt;input qualifier&gt; &lt;input name&gt;\n</code></pre> <p>Input names can be treated like a variable, and while the name is arbitrary, it should be recognizable.</p> <p>No quote marks are needed for variable inputs.</p> <pre><code>val greeting\n</code></pre> <p>Exercise</p> <p>Add an <code>input</code> block to the <code>SAYHELLO</code> process  with an input. Update the comment at the same time.</p> Solution hello-world.nf<pre><code>// Use echo to print a string and redirect to output.txt\nprocess SAYHELLO {\n    publishDir 'results'\n\n    input:\n    val greeting\n\n    output:\n    path 'output.txt'\n\n    script:\n    \"\"\"\n    echo 'Hello World!' &gt; output.txt\n    \"\"\"\n}\n</code></pre> <p>The <code>SAYHELLO</code> process is now expecting an input value.</p> <p>The <code>greeting_ch</code> channel can now be supplied to <code>SAYHELLO()</code> process within the workflow block:</p> <pre><code>SAYHELLO(greeting_ch)\n</code></pre> <p>Without this, Nextflow will throw an error.</p> <p>Exercise</p> <p>Add the <code>greeting_ch</code> as an input for the <code>SAYHELLO</code> process.</p> Solution hello-world.nf<pre><code>workflow {\n\n    // Create a channel for inputs\n    greeting_ch = Channel.of('Hello world!')\n\n    // Emit a greeting\n    SAYHELLO(greeting_ch)\n}\n</code></pre> <p>The final piece is to update the <code>script</code> block to use the <code>input</code> value.</p> <p>For an input to be treated like a variable in the script block, a <code>$</code> must be prepended to the input name:</p> <pre><code>echo '$greeting' &gt; output.txt\n</code></pre> <p>The <code>'</code> around <code>$greeting</code> are required to treat the greeting as a single string.</p> <p>Exercise</p> <p>Update <code>hello-world.nf</code> to use the greeting input.</p> Solution hello-world.nf<pre><code>// Use echo to print 'Hello World!' and redirect to output.txt\nprocess SAYHELLO {\n    publishDir 'results'\n\n    input:\n    val greeting\n\n    output:\n    path 'output.txt'\n\n    script:\n    \"\"\"\n    echo '$greeting' &gt; output.txt\n    \"\"\"\n}\n\nworkflow {\n\n    // Create a channel for inputs\n    greeting_ch = Channel.of('Hello world!')\n\n    // Emit a greeting\n    SAYHELLO(greeting_ch)\n}\n</code></pre> <p>Note</p> <p>The number of inputs in the input block and the workflow must match! If you had multiple inputs they would be listed across multiple lines in the process input block and listed inside the brackets in the workflow block.</p> Example example.nf<pre><code>process MYFUNCTION {\n    debug true\n\n    input:\n    val input_1\n    val input_2\n\n    output:\n    stdout\n\n    script:\n    \"\"\"\n    echo $input_1 $input_2\n    \"\"\"\n}\n\nworkflow {\n    MYFUNCTION('Hello', 'World!')\n}\n</code></pre> <p>Yes! Your pipeline now uses an input channel!</p> <p>Summary</p> <p>In this step you have learned:</p> <ol> <li>How to use Channel factories</li> <li>How to how to add process inputs</li> </ol>"},{"location":"content/06_params/","title":"Parameters","text":"<p>Learning objectives</p> <ol> <li>Implement pipeline parameters</li> <li>Understand the importance of parameters for flexible pipelines</li> </ol> <p>Parameters are constructs that can hold command line arguments.</p> <p>Here you're going to update the script with parameters to make it more flexible.</p>"},{"location":"content/06_params/#why-are-parameters-useful","title":"Why are parameters useful?","text":"<p>Nextflow has multiple levels of configuration and, as different levels may have conflicting settings, they are ranked in order of priority and some configuration can be overridden.</p> <p>Parameters are useful because they can be set with a default value in a script but can then be overwritten at runtime using a flag. Simply, parameters allow us to configure some aspect of a pipeline without editing the script itself.</p> <p>Parameters can be created by prefixing a parameter name with the parameters scope (e.g., <code>params.greeting</code>) and are accessible by processes and workflows. They can be modified when you run your pipeline by adding a double hyphen (<code>--</code>) to the start of the parameter name (<code>--greeting</code>) and adding it to an execution command:</p> <pre><code>nextflow run hello-world.nf --greeting 'Hey'\n</code></pre>"},{"location":"content/06_params/#-greeting","title":"<code>--greeting</code>","text":"<p>Instead of hard coding 'Hello World!' as an input, a parameter, with a default value, can be created:</p> <pre><code>params.greeting = 'Hello World!'\n</code></pre> <p>The parameter can then be used in a channel factory (just like the hard coded string):</p> <pre><code>greeting_ch = Channel.of(params.greeting)\n</code></pre> <p>The parameter can then be flexibly changed using a <code>--greeting</code> flag in the run command:</p> <pre><code>nextflow run hello-world.nf --greeting 'Bonjour le monde!'\n</code></pre> <p>Exercise</p> <p>Update the <code>hello-world.nf</code> script to use a <code>greeting</code> parameter as an input. Define the default for the <code>greeting</code> parameter at the top of the script and give it the default value <code>'Hello World!'</code>.</p> Solution hello-world.nf<pre><code>// Set default greeting\nparams.greeting = 'Hello World!'\n\n// Use echo to print 'Hello World!' and redirect to output.txt\nprocess SAYHELLO {\n    publishDir 'results'\n\n    input:\n    val greeting\n\n    output:\n    path 'output.txt'\n\n    script:\n    \"\"\"\n    echo '$greeting' &gt; output.txt\n    \"\"\"\n}\n\nworkflow {\n\n    // Create a channel for inputs\n    greeting_ch = Channel.of(params.greeting)\n\n    // Emit a greeting\n    SAYHELLO(greeting_ch)\n\n}\n</code></pre> <p>The <code>hello-world.nf</code> pipeline can now be executed with the <code>--greeting</code> flag and a custom greeting:</p> <pre><code>nextflow run hello-world.nf --greeting 'Bonjour le monde!'\n</code></pre>"},{"location":"content/06_params/#-outdir","title":"<code>--outdir</code>","text":"<p>It isn't very convenient to have the same output directory created every time you run your pipeline as the results are being overwritten.</p> <p>Instead, a parameter can be used so you can change the publishing directory for every execution:</p> <pre><code>publishDir params.outdir\n</code></pre> <p>A default value can be used for convenience as Nextflow will throw and error if <code>publishDir</code> is set to <code>null</code>.</p> <pre><code>params.outdir = 'results'\n</code></pre> <p>However, you may consider having no default value here and letting the pipeline fail to prevent the accidental overwriting of results.</p> <p>Exercise</p> <p>Update the <code>hello-world.nf</code> script to use an <code>outdir</code> parameter as the publishing directory. Define the default for the <code>outdir</code> parameter at the top of the script and give it the default value <code>'results'</code>.</p> Solution hello-world.nf<pre><code>// Set default greeting\nparams.greeting = 'Hello World!'\n\n// Set default output directory\nparams.outdir = 'results'\n\n// Use echo to print 'Hello World!' and redirect to output.txt\nprocess SAYHELLO {\n    publishDir params.outdir\n\n    input:\n    val greeting\n\n    output:\n    path 'output.txt'\n\n    script:\n    \"\"\"\n    echo '$greeting' &gt; output.txt\n    \"\"\"\n}\n\nworkflow {\n\n    // Create a channel for inputs\n    greeting_ch = Channel.of(params.greeting)\n\n    // Emit a greeting\n    SAYHELLO(greeting_ch)\n\n}\n</code></pre> <p>Summary</p> <p>In this step you have learned:</p> <ol> <li>How to how to add a parameter to a pipeline</li> <li>How to modify a parameter using the command line</li> </ol>"},{"location":"content/07_process/","title":"Adding processes","text":"<p>Learning objectives</p> <ol> <li>Transform text strings </li> <li>Chain Nextflow processes together</li> <li>Utilize process outputs as inputs</li> </ol> <p>Up until now you've been modifying a single step. However, pipelines generally consist of multiple steps where outputs from one step are used as inputs for the next.</p> <p>Here you're going to step things up again and add another process to the pipeline.</p>"},{"location":"content/07_process/#translating-text","title":"Translating text","text":"<p>The <code>tr</code> command is a UNIX command-line utility for translating or deleting characters. It supports a range of transformations including uppercase to lowercase, squeezing repeating characters, deleting specific characters, and basic find and replace. It can be used with UNIX pipes to support more complex translation. <code>tr</code> stands for translate.</p> <pre><code>tr '[a-z]' '[A-Z]'`\n</code></pre>"},{"location":"content/07_process/#piping-commands","title":"Piping commands","text":"<p>The pipe command in Linux, represented by the vertical bar symbol <code>|</code>, is an essential tool for command-line enthusiasts and professionals alike. The primary purpose of the pipe command is to connect the output of one command directly into the input of another:</p> <pre><code>echo 'Hello World' | tr '[a-z]' '[A-Z]'\n</code></pre> <p>The contents of a file can be piped using the <code>cat</code> command:</p> <pre><code>cat output.txt | tr '[a-z]' '[A-Z]'\n</code></pre> <p>Like before, the output can be redirected to an output file:</p> <pre><code>cat output.txt | tr '[a-z]' '[A-Z]' &gt; upper.txt\n</code></pre>"},{"location":"content/07_process/#converttoupper","title":"<code>CONVERTTOUPPER</code>","text":"<p>The output of the <code>SAYHELLO</code> process is a text file called <code>output.txt</code>.</p> <p>In the next step of the pipeline, you will add a new process named convert <code>CONVERTTOUPPER</code> that will convert all of the lower case letters in this file to a uppercase letters and save them as a new file.</p> <p>The <code>CONVERTTOUPPER</code> process will follow the same structure as the <code>SAYHELLO</code> process:</p> <pre><code>process CONVERTTOUPPER {\n    publishDir params.outdir\n\n    input:\n    &lt;input qualifier&gt; &lt;input name&gt;\n\n    output:\n    &lt;output qualifier&gt; &lt;output name&gt;\n\n    script:\n    \"\"\"\n    &lt;script&gt;\n    \"\"\"\n}\n</code></pre> <p>Using what you have learned in the previous sections you will now write a new process using the <code>tr</code> command from above.</p> <p>Exercise</p> <p>Add new process named <code>CONVERTTOUPPER</code> that will take an input text file, convert all of the lowercase letters in the text file to uppercase letters, and save a new text file that contains the translated letters.</p> Hint: <code>input:</code> <pre><code>path input_file\n</code></pre> <p>Hint 1: The input is a file and requires the <code>path</code> qualifier.</p> <p>Hint 2: The input name is <code>input_file</code>, however, you may call it something different.</p> Hint: <code>output:</code> <p>The output</p> <pre><code>path 'upper_output.txt'\n</code></pre> <p>Hint 1: The output is a file and requires the <code>path</code> qualifier.</p> <p>Hint 2: The output name is hard coded as 'upper.txt', however, you may call it something different.</p> Hint: <code>script:</code> <p>The script might look something like this:</p> <pre><code>cat $input_file | tr '[a-z]' '[A-Z]' &gt; upper.txt\n</code></pre> <p>Hint 1: <code>input_file</code> must be the same as what was specified as the input name in the input block.</p> <p>Hint 2: The output text file is named <code>upper.txt</code></p> Solution hello-world.nf<pre><code>// Set default greeting\nparams.greeting = 'Hello World!'\n\n// Set a default output directory\nparams.outdir = 'results'\n\n// Use echo to print 'Hello World!' and redirect to output.txt\nprocess SAYHELLO {\n    publishDir params.outdir\n\n    input:\n    val greeting\n\n    output:\n    path 'output.txt'\n\n    script:\n    \"\"\"\n    echo '$greeting' &gt; output.txt\n    \"\"\"\n}\n\nprocess CONVERTTOUPPER {\n    publishDir params.outdir\n\n    input:\n        path input_file\n\n    output:\n        path 'upper.txt'\n\n    script:\n    \"\"\"\n    cat $input_file | tr '[a-z]' '[A-Z]' &gt; upper.txt\n    \"\"\"\n}\n\nworkflow {\n\n    // Create a channel for inputs\n    greeting_ch = Channel.of(params.greeting)\n\n    // Emit a greeting\n    SAYHELLO(greeting_ch)\n\n}\n</code></pre>"},{"location":"content/07_process/#connecting-processes","title":"Connecting processes","text":"<p>Outputs from one process can be used as inputs for another.</p> <p>Outputs from a process can be accessed by adding <code>.out</code> to the end of a process name in the workflow definition:</p> <pre><code>SAYHELLO.out\n</code></pre> <p>Outputs can then be used as an input for another process:</p> <pre><code>CONVERTTOUPPER(SAYHELLO.out)\n</code></pre> <p>The same output could be used as inputs for multiple processes.</p> <p>Warning</p> <p>Adding <code>.out</code> to the end of a process name only works for single outputs. If there are multiple outputs the <code>emit</code> option must be used. See additional options for more information.</p> <p>Exercise</p> <p>Add the <code>CONVERTTOUPPER</code> process to your workflow definition. Use the output from <code>SAYHELLO</code> as its input.</p> Solution hello-world.nf<pre><code>// Set default greeting\nparams.greeting = 'Hello World!'\n\n// Set a default output directory\nparams.outdir = 'results'\n\n// Use echo to print 'Hello World!' and redirect to output.txt\nprocess SAYHELLO {\n    publishDir params.outdir\n\n    input:\n    val greeting\n\n    output:\n    path 'output.txt'\n\n    script:\n    \"\"\"\n    echo '$greeting' &gt; output.txt\n    \"\"\"\n}\n\nprocess CONVERTTOUPPER {\n    publishDir params.outdir\n\n    input:\n        path input_file\n\n    output:\n        path 'upper.txt'\n\n    script:\n    \"\"\"\n    cat $input_file | tr '[a-z]' '[A-Z]' &gt; upper.txt\n    \"\"\"\n}\n\nworkflow {\n\n    // Create a channel for inputs\n    greeting_ch = Channel.of(params.greeting)\n\n    // Emit a greeting\n    SAYHELLO(greeting_ch)\n\n    // Convert the greeting to uppercase\n    CONVERTTOUPPER(SAYHELLO.out)\n\n}\n</code></pre> <p>Executing <code>hello-world.nf</code> will now show a second step:</p> <pre><code>N E X T F L O W  ~  version 23.10.1\nLaunching `hello-world.nf` [mighty_murdock] DSL2 - revision: 80e92a677c\nexecutor &gt;  local (2)\n[ef/b99a2f] SAYHELLO (1)       [100%] 1 of 1 \u2714\n[cd/c8cf1b] CONVERTTOUPPER (1) [100%] 1 of 1 \u2714\n</code></pre> <p>Summary</p> <p>In this step you have learned:</p> <ol> <li>How to translate strings</li> <li>How add more processes to a script</li> <li>How to use outputs and inputs</li> </ol>"},{"location":"content/08_dynamic/","title":"Dynamic naming","text":"<p>Learning objectives</p> <ol> <li>Dynamically name variables in Nextflow</li> </ol> <p>Currently, the outputs of the <code>SAYHELLO</code> and <code>CONVERTTOUPPER</code> processes are being saved as <code>output.txt</code> and <code>upper.txt</code>, respectively.</p> <p>In some situations this would be fine. However, to help identify the outputs you want your outputs to be dynamic.</p> <p>Let's get tricky and name your output files dynamically.</p>"},{"location":"content/08_dynamic/#dynamic-outputs","title":"Dynamic outputs","text":"<p>When an output file name needs to be expressed dynamically, it is possible to define it using a dynamic string that references values defined in the input declaration block or in the script global context.</p> <p>For example, the <code>SAYHELLO</code> input value <code>greeting</code> can be used to help name the output file.</p> <pre><code>process SAYHELLO {\n    publishDir 'results'\n\n    input:\n    val greeting\n\n    output:\n    path \"${greeting}.txt\"\n\n    script:\n    \"\"\"\n    echo '$greeting' &gt; ${greeting}.txt\n    \"\"\"\n}\n</code></pre> <p>Curly brackets <code>{}</code> have been used to wrap <code>greeting</code> in the <code>output</code> and <code>script</code> block so it is interpreted as a variable as a part of a file name.</p> <p>There is an important difference between single-quoted (<code>'</code>) and double-quoted (<code>\"</code>)strings. Double-quoted strings support variable interpolations while single-quoted strings do not.</p> <p>Exercise</p> <p>Update the <code>SAYHELLO</code> and <code>CONVERTTOUPPER</code> process to use dynamic output names.</p> <p>Warning</p> <p>It's difficult to name a file with a space. Use a simple greeting without spaces, e.g., \"Hello\", when testing your pipeline.</p> Solution hello-world.nf<pre><code>// Use echo to print 'Hello World!' and redirect to output.txt\nprocess SAYHELLO {\n    publishDir 'results'\n\n    input:\n    val greeting\n\n    output:\n    path \"${greeting}.txt\"\n\n    script:\n    \"\"\"\n    echo '$greeting' &gt; ${greeting}.txt\n    \"\"\"\n}\n\n// Use tr to convert lowercase letters to upper case letters and save as upper.txt\nprocess CONVERTTOUPPER {\n    publishDir 'results'\n\n    input:\n        path input_file\n\n    output:\n        path \"upper_${input_file}\"\n\n    script:\n    \"\"\"\n    cat $input_file | tr '[a-z]' '[A-Z]' &gt; upper_${input_file}\n    \"\"\"\n}\n\nworkflow {\n\n    // Set default greeting\n    params.greeting = \"Hello\"\n\n    // Create a channel for inputs\n    greeting_ch = Channel.of(params.greeting)\n\n    // Emit a greeting\n    SAYHELLO(greeting_ch)\n\n    // Convert the greeting to uppercase\n    CONVERTTOUPPER(SAYHELLO.out)\n\n}\n</code></pre> <p>Let's execute your pipeline and view the changes to see if your outputs have been named dynamically.</p> <pre><code>nextflow run hello-world.nf --greeting 'Hello'\n</code></pre> <p>While the output will look the same:</p> <pre><code>N E X T F L O W  ~  version 23.10.1\nLaunching `hello-world.nf` [mighty_murdock] DSL2 - revision: 80e92a677c\nexecutor &gt;  local (2)\n[ef/b99a2f] SAYHELLO (1)       [100%] 1 of 1 \u2714\n[cd/c8cf1b] CONVERTTOUPPER (1) [100%] 1 of 1 \u2714\n</code></pre> <p>You should now see some new files in your results folder:</p> <ul> <li><code>Hello.txt</code></li> <li><code>upper_Hello.txt</code></li> </ul> <p>Summary</p> <p>In this step you have learned:</p> <ol> <li>How to utilize dynamic naming</li> <li>How to use curly brackets (<code>{}</code>)</li> <li>How to use single (<code>'</code>) and double (<code>\"</code>) quotes</li> </ol>"}]}